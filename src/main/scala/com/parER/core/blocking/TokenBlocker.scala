package com.parER.core.blocking

import com.parER.datastructure.InvertedIndex
import gnu.trove.map.hash.TObjectIntHashMap
import org.scify.jedai.textmodels.TokenNGrams

class TokenBlocker extends Blocking {

  val invertedIndex = new InvertedIndex
  protected var modelStoring = true
  val frequencyKeys = new TObjectIntHashMap[String]

  override def setModelStoring(value: Boolean) = {
    modelStoring = value
    println("Model storing? " + modelStoring)
  }

  // Here you return the total number of comparisons generated by the textModel
  override def execute(idx: Int, textModel: TokenNGrams) = {
    import scala.jdk.CollectionConverters._
    val textModelTokens = textModel.getSignatures.asScala.toList
    execute(idx, textModel, textModelTokens)
  }

  override def execute(idx: Int, textModel: TokenNGrams, keys: List[String]) = {

    // generate comparisons in the form e1, e2 with e1 < e2 => e2 current idx
    val comparisons = invertedIndex.generate(idx, textModel, keys, modelStoring)   // TODO make packages of fixed size

    // update indexes
    invertedIndex.update(idx, textModel, keys, modelStoring)

    comparisons
  }

  override def process(idx: Int, textModel: TokenNGrams) = {
    import scala.jdk.CollectionConverters._
    val textModelTokens = textModel.getSignatures.asScala.toList
    process(idx, textModel, textModelTokens)
  }

  // THIS METHOD SUPPORTS ONLY THE SCENARIO WHERE MODELSTORING IS FALSE
  override def process(idx: Int, textModel: TokenNGrams, keys: List[String]) = {
    val dId = textModel.getDatasetId
    // get blocks and apply block cutting and first step of block filtering
    val associatedBlocks = invertedIndex.getBlocks(idx, dId, keys)
    // build tuple and update inverted index data structure
    val blocks = associatedBlocks.values.map(_.toList).toList
    val tuple = (idx, textModel, blocks)
    invertedIndex.update(idx, textModel, associatedBlocks.keys.toList, modelStoring)
    tuple
  }

  override def processPrefix(idx: Int, textModel: TokenNGrams) = {
    import scala.jdk.CollectionConverters._
    val textModelTokens = textModel.getSignatures.asScala.toList
    processPrefix(idx, textModel, textModelTokens)
  }

  override def processPrefix(idx: Int, textModel: TokenNGrams, keys: List[String]): ((Int, TokenNGrams, List[List[Int]], List[(String)]), Int) = ???

}
